// Code generated by sqlc. DO NOT EDIT.

import type { Database } from "./db"

import { mapRowToObj, numberToBool } from "./utils"

const listUnsyncedChangesQuery = `-- name: ListUnsyncedChanges :many
SELECT id, source, revision, target_type, target_id, value, applied, synced, applied_at, synced_at, created_at, updated_at
FROM changelog
WHERE
    CASE WHEN ?1 IS NOT NULL THEN id > ?1 ELSE true END
    AND synced = false
ORDER BY revision
LIMIT ?2`

export interface ListUnsyncedChangesArgs {
    chlgPageAfter: any | null
    pageSize: number
}

export interface ListUnsyncedChangesRow {
    id: number
    source: string
    revision: number
    targetType: string
    targetId: string
    value: any
    applied: boolean
    synced: boolean
    appliedAt: string | null
    syncedAt: string | null
    createdAt: string
    updatedAt: string
}

export async function listUnsyncedChanges(
    database: Database,
    args: ListUnsyncedChangesArgs,
    abort?: AbortSignal,
): Promise<ListUnsyncedChangesRow[]> {
    let result = await database.query(
        listUnsyncedChangesQuery,
        [args.chlgPageAfter, args.pageSize],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListUnsyncedChangesRow>(row, {
            applied: numberToBool,
            synced: numberToBool,
        }),
    )
}

const listUnappliedChangesQuery = `-- name: ListUnappliedChanges :many
SELECT id, source, revision, target_type, target_id, value, applied, synced, applied_at, synced_at, created_at, updated_at
FROM changelog
WHERE
    CASE WHEN ?1 IS NOT NULL THEN id > ?1 ELSE true END
    AND applied = false
ORDER BY revision
LIMIT ?2`

export interface ListUnappliedChangesArgs {
    chlgPageAfter: any | null
    pageSize: number
}

export interface ListUnappliedChangesRow {
    id: number
    source: string
    revision: number
    targetType: string
    targetId: string
    value: any
    applied: boolean
    synced: boolean
    appliedAt: string | null
    syncedAt: string | null
    createdAt: string
    updatedAt: string
}

export async function listUnappliedChanges(
    database: Database,
    args: ListUnappliedChangesArgs,
    abort?: AbortSignal,
): Promise<ListUnappliedChangesRow[]> {
    let result = await database.query(
        listUnappliedChangesQuery,
        [args.chlgPageAfter, args.pageSize],
        abort,
    )
    return result.map((row) =>
        mapRowToObj<ListUnappliedChangesRow>(row, {
            applied: numberToBool,
            synced: numberToBool,
        }),
    )
}

const createChangelogEntryQuery = `-- name: CreateChangelogEntry :exec
INSERT INTO changelog(
    source,
    revision,
    target_type,
    target_id,
    value,
    synced,
    applied
) VALUES (
    ?1,
    (CASE WHEN ?2 > 0 THEN
        ?2
        ELSE
        COALESCE(
            (SELECT MAX(revision) + 1 as revision FROM changelog WHERE target_type = ?3 AND target_id = ?4),
            1
        )
    END),
    ?3,
    ?4,
    ?5,
    ?6,
    ?7
)`

export interface CreateChangelogEntryArgs {
    source: string
    revision: any | null
    targetType: string
    targetId: string
    value: any
    synced: boolean
    applied: boolean
}

export async function createChangelogEntry(
    database: Database,
    args: CreateChangelogEntryArgs,
    abort?: AbortSignal,
) {
    await database.exec(
        createChangelogEntryQuery,
        [
            args.source,
            args.revision,
            args.targetType,
            args.targetId,
            args.value,
            args.synced,
            args.applied,
        ],
        abort,
    )
}
