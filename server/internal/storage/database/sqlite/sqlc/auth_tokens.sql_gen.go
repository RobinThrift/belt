// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auth_tokens.sql

package sqlc

import (
	"context"

	"go.robinthrift.com/belt/internal/auth"
	"go.robinthrift.com/belt/internal/domain"
	"go.robinthrift.com/belt/internal/storage/database/sqlite/types"
)

const createAuthToken = `-- name: CreateAuthToken :one
INSERT INTO auth_tokens(
    account_id,
    value,
    expires_at,
    refresh_value,
    refresh_expires_at,
    is_valid
) VALUES (?, ?, ?, ?, ?, TRUE)
RETURNING id
`

type CreateAuthTokenParams struct {
	AccountID        domain.AccountID
	Value            []byte
	ExpiresAt        types.SQLiteDatetime
	RefreshValue     []byte
	RefreshExpiresAt types.SQLiteDatetime
}

func (q *Queries) CreateAuthToken(ctx context.Context, db DBTX, arg CreateAuthTokenParams) (auth.AuthTokenID, error) {
	row := db.QueryRowContext(ctx, createAuthToken,
		arg.AccountID,
		arg.Value,
		arg.ExpiresAt,
		arg.RefreshValue,
		arg.RefreshExpiresAt,
	)
	var id auth.AuthTokenID
	err := row.Scan(&id)
	return id, err
}

const deleteInvalidTokens = `-- name: DeleteInvalidTokens :exec
DELETE FROM auth_tokens WHERE is_valid = FALSE
`

func (q *Queries) DeleteInvalidTokens(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, deleteInvalidTokens)
	return err
}

const getAuthToken = `-- name: GetAuthToken :one
SELECT id, account_id, value, expires_at, refresh_value, refresh_expires_at, is_valid, created_at FROM auth_tokens WHERE value = ? AND datetime(expires_at) > datetime("now") AND is_valid = TRUE LIMIT 1
`

func (q *Queries) GetAuthToken(ctx context.Context, db DBTX, value []byte) (AuthToken, error) {
	row := db.QueryRowContext(ctx, getAuthToken, value)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Value,
		&i.ExpiresAt,
		&i.RefreshValue,
		&i.RefreshExpiresAt,
		&i.IsValid,
		&i.CreatedAt,
	)
	return i, err
}

const getAuthTokenByID = `-- name: GetAuthTokenByID :one
SELECT id, account_id, value, expires_at, refresh_value, refresh_expires_at, is_valid, created_at FROM auth_tokens WHERE id = ? AND account_id = ? LIMIT 1
`

type GetAuthTokenByIDParams struct {
	ID        auth.AuthTokenID
	AccountID domain.AccountID
}

func (q *Queries) GetAuthTokenByID(ctx context.Context, db DBTX, arg GetAuthTokenByIDParams) (AuthToken, error) {
	row := db.QueryRowContext(ctx, getAuthTokenByID, arg.ID, arg.AccountID)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Value,
		&i.ExpiresAt,
		&i.RefreshValue,
		&i.RefreshExpiresAt,
		&i.IsValid,
		&i.CreatedAt,
	)
	return i, err
}

const getAuthTokenByRefreshValue = `-- name: GetAuthTokenByRefreshValue :one
SELECT id, account_id, value, expires_at, refresh_value, refresh_expires_at, is_valid, created_at FROM auth_tokens WHERE refresh_value = ? AND datetime(refresh_expires_at) > datetime("now") AND is_valid = TRUE LIMIT 1
`

func (q *Queries) GetAuthTokenByRefreshValue(ctx context.Context, db DBTX, refreshValue []byte) (AuthToken, error) {
	row := db.QueryRowContext(ctx, getAuthTokenByRefreshValue, refreshValue)
	var i AuthToken
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Value,
		&i.ExpiresAt,
		&i.RefreshValue,
		&i.RefreshExpiresAt,
		&i.IsValid,
		&i.CreatedAt,
	)
	return i, err
}

const invalidateAuthToken = `-- name: InvalidateAuthToken :exec
UPDATE auth_tokens
SET is_valid = false
WHERE value = ?
`

func (q *Queries) InvalidateAuthToken(ctx context.Context, db DBTX, value []byte) error {
	_, err := db.ExecContext(ctx, invalidateAuthToken, value)
	return err
}

const markExpiredAuthTokensAsInvalid = `-- name: MarkExpiredAuthTokensAsInvalid :exec
UPDATE auth_tokens
SET is_valid = false
WHERE datetime(refresh_expires_at) > datetime("now")
`

func (q *Queries) MarkExpiredAuthTokensAsInvalid(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, markExpiredAuthTokensAsInvalid)
	return err
}
