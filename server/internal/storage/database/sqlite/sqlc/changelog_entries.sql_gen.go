// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: changelog_entries.sql

package sqlc

import (
	"context"

	"go.robinthrift.com/belt/internal/domain"
	"go.robinthrift.com/belt/internal/storage/database/sqlite/types"
)

const createChangelogEntry = `-- name: CreateChangelogEntry :exec
INSERT INTO changelog_entries(
    account_id,
    sync_client_id,
    data,
    timestamp
) VALUES (?, ?, ?, ?)
`

type CreateChangelogEntryParams struct {
	AccountID    domain.AccountID
	SyncClientID domain.SyncClientID
	Data         []byte
	Timestamp    types.SQLiteDatetime
}

func (q *Queries) CreateChangelogEntry(ctx context.Context, db DBTX, arg CreateChangelogEntryParams) error {
	_, err := db.ExecContext(ctx, createChangelogEntry,
		arg.AccountID,
		arg.SyncClientID,
		arg.Data,
		arg.Timestamp,
	)
	return err
}

const listChangelogEntries = `-- name: ListChangelogEntries :many
SELECT id, account_id, sync_client_id, data, timestamp FROM changelog_entries
WHERE
    account_id = ?
    AND timestamp >= datetime(?)
ORDER BY timestamp DESC
`

type ListChangelogEntriesParams struct {
	AccountID domain.AccountID
	Since     interface{}
}

func (q *Queries) ListChangelogEntries(ctx context.Context, db DBTX, arg ListChangelogEntriesParams) ([]ChangelogEntry, error) {
	rows, err := db.QueryContext(ctx, listChangelogEntries, arg.AccountID, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangelogEntry
	for rows.Next() {
		var i ChangelogEntry
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.SyncClientID,
			&i.Data,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
