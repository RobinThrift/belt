// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: accounts.sql

package sqlc

import (
	"context"

	"go.robinthrift.com/belt/internal/domain"
	"go.robinthrift.com/belt/internal/storage/database/sqlite/types"
)

const countAccounts = `-- name: CountAccounts :one
SELECT COUNT(*) as count FROM accounts
`

func (q *Queries) CountAccounts(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, countAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts(
    username,
    algorithm,
    params,
    salt,
    password
) VALUES (?, ?, ?, ?, ?)
`

type CreateAccountParams struct {
	Username  string
	Algorithm string
	Params    string
	Salt      []byte
	Password  []byte
}

func (q *Queries) CreateAccount(ctx context.Context, db DBTX, arg CreateAccountParams) error {
	_, err := db.ExecContext(ctx, createAccount,
		arg.Username,
		arg.Algorithm,
		arg.Params,
		arg.Salt,
		arg.Password,
	)
	return err
}

const createAccountKey = `-- name: CreateAccountKey :exec
INSERT INTO account_keys(
    account_id,
    name,
    type,
    data
) VALUES (?, ?, ?, ?)
ON CONFLICT (account_id, name, data) DO NOTHING
`

type CreateAccountKeyParams struct {
	AccountID int64
	Name      string
	Type      string
	Data      []byte
}

func (q *Queries) CreateAccountKey(ctx context.Context, db DBTX, arg CreateAccountKeyParams) error {
	_, err := db.ExecContext(ctx, createAccountKey,
		arg.AccountID,
		arg.Name,
		arg.Type,
		arg.Data,
	)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT
    accounts.id, accounts.username, accounts.algorithm, accounts.params, accounts.salt, accounts.password, accounts.requires_password_change, accounts.created_at, accounts.updated_at
FROM accounts
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetAccount(ctx context.Context, db DBTX, id domain.AccountID) (Account, error) {
	row := db.QueryRowContext(ctx, getAccount, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Algorithm,
		&i.Params,
		&i.Salt,
		&i.Password,
		&i.RequiresPasswordChange,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByUsername = `-- name: GetAccountByUsername :one
SELECT
    accounts.id, accounts.username, accounts.algorithm, accounts.params, accounts.salt, accounts.password, accounts.requires_password_change, accounts.created_at, accounts.updated_at
FROM accounts
WHERE username = ?
LIMIT 1
`

func (q *Queries) GetAccountByUsername(ctx context.Context, db DBTX, username string) (Account, error) {
	row := db.QueryRowContext(ctx, getAccountByUsername, username)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Algorithm,
		&i.Params,
		&i.Salt,
		&i.Password,
		&i.RequiresPasswordChange,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountKey = `-- name: GetAccountKey :one
SELECT id, account_id, name, type, data, created_at, updated_at FROM account_keys
WHERE name = ? AND account_id = ?
LIMIT 1
`

type GetAccountKeyParams struct {
	Name      string
	AccountID int64
}

func (q *Queries) GetAccountKey(ctx context.Context, db DBTX, arg GetAccountKeyParams) (AccountKey, error) {
	row := db.QueryRowContext(ctx, getAccountKey, arg.Name, arg.AccountID)
	var i AccountKey
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Data,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccount = `-- name: UpdateAccount :exec
UPDATE accounts SET
    algorithm = ?,
    params = ?,
    salt = ?,
    password = ?,
	requires_password_change = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateAccountParams struct {
	Algorithm              string
	Params                 string
	Salt                   []byte
	Password               []byte
	RequiresPasswordChange bool
	UpdatedAt              types.SQLiteDatetime
	ID                     domain.AccountID
}

func (q *Queries) UpdateAccount(ctx context.Context, db DBTX, arg UpdateAccountParams) error {
	_, err := db.ExecContext(ctx, updateAccount,
		arg.Algorithm,
		arg.Params,
		arg.Salt,
		arg.Password,
		arg.RequiresPasswordChange,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
