// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package sqlc

import (
	"context"

	"go.robinthrift.com/conveyor/internal/storage/database/sqlite/types"
)

const createJob = `-- name: CreateJob :exec
INSERT INTO jobs(
    kind,
    data,
    scheduled_for
) VALUES (?, ?, ?)
`

type CreateJobParams struct {
	Kind         string
	Data         types.SQLiteJSON
	ScheduledFor types.SQLiteDatetime
}

func (q *Queries) CreateJob(ctx context.Context, db DBTX, arg CreateJobParams) error {
	_, err := db.ExecContext(ctx, createJob, arg.Kind, arg.Data, arg.ScheduledFor)
	return err
}

const getNextWakeUpTime = `-- name: GetNextWakeUpTime :one
SELECT scheduled_for
FROM jobs
WHERE state = "scheduled"
ORDER BY scheduled_for DESC
LIMIT 1
`

func (q *Queries) GetNextWakeUpTime(ctx context.Context, db DBTX) (types.SQLiteDatetime, error) {
	row := db.QueryRowContext(ctx, getNextWakeUpTime)
	var scheduled_for types.SQLiteDatetime
	err := row.Scan(&scheduled_for)
	return scheduled_for, err
}

const listNextJobs = `-- name: ListNextJobs :many
SELECT id, state, kind, data, result, scheduled_for, created_at, finished_at
FROM jobs
WHERE
    datetime(scheduled_for) <= datetime(CAST(?1 AS TEXT))
    AND state = "scheduled"
ORDER BY scheduled_for DESC
`

func (q *Queries) ListNextJobs(ctx context.Context, db DBTX, scheduledFor string) ([]Job, error) {
	rows, err := db.QueryContext(ctx, listNextJobs, scheduledFor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.Kind,
			&i.Data,
			&i.Result,
			&i.ScheduledFor,
			&i.CreatedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs
SET
    state = ?,
    result = ?,
    finished_at = ?
WHERE id = ?
`

type UpdateJobParams struct {
	State      interface{}
	Result     types.SQLiteJSON
	FinishedAt types.SQLiteDatetime
	ID         int64
}

func (q *Queries) UpdateJob(ctx context.Context, db DBTX, arg UpdateJobParams) error {
	_, err := db.ExecContext(ctx, updateJob,
		arg.State,
		arg.Result,
		arg.FinishedAt,
		arg.ID,
	)
	return err
}
