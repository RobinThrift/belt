// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: memos.sql

package sqlc

import (
	"context"

	"github.com/RobinThrift/belt/internal/auth"
	"github.com/RobinThrift/belt/internal/domain"
	"github.com/RobinThrift/belt/internal/storage/database/sqlite/types"
)

const archiveMemo = `-- name: ArchiveMemo :execrows
UPDATE memos SET
    is_archived = true,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE id = ?
`

func (q *Queries) ArchiveMemo(ctx context.Context, db DBTX, id domain.MemoID) (int64, error) {
	result, err := db.ExecContext(ctx, archiveMemo, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const cleanupDeletedMemos = `-- name: CleanupDeletedMemos :execrows
DELETE FROM memos WHERE is_deleted = true AND date(updated_at) < date('now','-30 days')
`

func (q *Queries) CleanupDeletedMemos(ctx context.Context, db DBTX) (int64, error) {
	result, err := db.ExecContext(ctx, cleanupDeletedMemos)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createMemo = `-- name: CreateMemo :one
INSERT INTO memos(
    content,
    created_by,
    created_at
) VALUES (?, ?, ?)
RETURNING id
`

type CreateMemoParams struct {
	Content   []byte
	CreatedBy auth.AccountID
	CreatedAt types.SQLiteDatetime
}

func (q *Queries) CreateMemo(ctx context.Context, db DBTX, arg CreateMemoParams) (domain.MemoID, error) {
	row := db.QueryRowContext(ctx, createMemo, arg.Content, arg.CreatedBy, arg.CreatedAt)
	var id domain.MemoID
	err := row.Scan(&id)
	return id, err
}

const getMemo = `-- name: GetMemo :one
SELECT id, content, is_archived, is_deleted, created_by, created_at, updated_at
FROM memos
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetMemo(ctx context.Context, db DBTX, id domain.MemoID) (Memo, error) {
	row := db.QueryRowContext(ctx, getMemo, id)
	var i Memo
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsArchived,
		&i.IsDeleted,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArchivedMemos = `-- name: ListArchivedMemos :many
SELECT id, content, is_archived, is_deleted, created_by, created_at, updated_at
FROM memos
WHERE
    is_archived = true
    AND is_deleted = false
    AND id > ?
ORDER BY created_at DESC
LIMIT ?
`

type ListArchivedMemosParams struct {
	ID    domain.MemoID
	Limit int64
}

func (q *Queries) ListArchivedMemos(ctx context.Context, db DBTX, arg ListArchivedMemosParams) ([]Memo, error) {
	rows, err := db.QueryContext(ctx, listArchivedMemos, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memo
	for rows.Next() {
		var i Memo
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedMemos = `-- name: ListDeletedMemos :many
SELECT id, content, is_archived, is_deleted, created_by, created_at, updated_at
FROM memos
WHERE
    is_deleted = true
    AND id > ?
ORDER BY created_at DESC
LIMIT ?
`

type ListDeletedMemosParams struct {
	ID    domain.MemoID
	Limit int64
}

func (q *Queries) ListDeletedMemos(ctx context.Context, db DBTX, arg ListDeletedMemosParams) ([]Memo, error) {
	rows, err := db.QueryContext(ctx, listDeletedMemos, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memo
	for rows.Next() {
		var i Memo
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemos = `-- name: ListMemos :many
SELECT id, content, is_archived, is_deleted, created_by, created_at, updated_at
FROM memos
WHERE
    is_archived = false
    AND is_deleted = false
    AND CASE WHEN ?1 IS NOT NULL THEN created_at < datetime(?1) ELSE true END
    AND CASE WHEN CAST(?2 as BOOLEAN) THEN date(created_at) = date(?3) ELSE true END
    AND CASE WHEN CAST(?4 as BOOLEAN) THEN date(created_at) <= date(?5) ELSE true END
ORDER BY created_at DESC
LIMIT ?6
`

type ListMemosParams struct {
	PageAfter            interface{}
	WithCreatedAt        bool
	CreatedAt            interface{}
	WithCreatedAtOrOlder bool
	CreatedAtOrOlder     interface{}
	PageSize             int64
}

func (q *Queries) ListMemos(ctx context.Context, db DBTX, arg ListMemosParams) ([]Memo, error) {
	rows, err := db.QueryContext(ctx, listMemos,
		arg.PageAfter,
		arg.WithCreatedAt,
		arg.CreatedAt,
		arg.WithCreatedAtOrOlder,
		arg.CreatedAtOrOlder,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Memo
	for rows.Next() {
		var i Memo
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemosForTags = `-- name: ListMemosForTags :many
SELECT memos.id, content, is_archived, is_deleted, created_by, memos.created_at, updated_at, memo_tags.id, memo_id, tag, memo_tags.created_at FROM memos
JOIN memo_tags ON memo_id = memos.id
WHERE
    is_archived = false
    AND is_deleted = false
    AND CASE WHEN ?1 IS NOT NULL THEN memos.created_at < datetime(?1) ELSE true END
    AND memo_tags.tag = ?2
    AND CASE WHEN CAST(?3 as BOOLEAN) THEN date(memos.created_at) = date(?4) ELSE true END
    AND CASE WHEN CAST(?5 as BOOLEAN) THEN date(memos.created_at) <= date(?6) ELSE true END
ORDER BY memos.created_at DESC
LIMIT ?7
`

type ListMemosForTagsParams struct {
	PageAfter            interface{}
	Tag                  string
	WithCreatedAt        bool
	CreatedAt            interface{}
	WithCreatedAtOrOlder bool
	CreatedAtOrOlder     interface{}
	PageSize             int64
}

type ListMemosForTagsRow struct {
	ID          domain.MemoID
	Content     []byte
	IsArchived  bool
	IsDeleted   bool
	CreatedBy   auth.AccountID
	CreatedAt   types.SQLiteDatetime
	UpdatedAt   types.SQLiteDatetime
	ID_2        int64
	MemoID      int64
	Tag         string
	CreatedAt_2 string
}

func (q *Queries) ListMemosForTags(ctx context.Context, db DBTX, arg ListMemosForTagsParams) ([]ListMemosForTagsRow, error) {
	rows, err := db.QueryContext(ctx, listMemosForTags,
		arg.PageAfter,
		arg.Tag,
		arg.WithCreatedAt,
		arg.CreatedAt,
		arg.WithCreatedAtOrOlder,
		arg.CreatedAtOrOlder,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemosForTagsRow
	for rows.Next() {
		var i ListMemosForTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.MemoID,
			&i.Tag,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemosForTagsWithSearch = `-- name: ListMemosForTagsWithSearch :many
SELECT memos_fts.id, content, is_archived, is_deleted, created_by, memos_fts.created_at, updated_at, memo_tags.id, memo_id, tag, memo_tags.created_at FROM memos_fts
JOIN memo_tags ON memo_id = memos_fts.id
WHERE
    is_archived = false
    AND is_deleted = false
    AND CASE WHEN ?1 IS NOT NULL THEN memos_fts.created_at < datetime(?1) ELSE true END
    AND memo_tags.tag = ?2
    AND content MATCH CAST(?3 as TEXT)
    AND CASE WHEN CAST(?4 as BOOLEAN) THEN date(memos_fts.created_at) = date(?5) ELSE true END
    AND CASE WHEN CAST(?6 as BOOLEAN) THEN date(memos_fts.created_at) <= date(?7) ELSE true END
ORDER BY memos_fts.created_at DESC, rank
LIMIT ?8
`

type ListMemosForTagsWithSearchParams struct {
	PageAfter            interface{}
	Tag                  string
	Search               string
	WithCreatedAt        bool
	CreatedAt            interface{}
	WithCreatedAtOrOlder bool
	CreatedAtOrOlder     interface{}
	PageSize             int64
}

type ListMemosForTagsWithSearchRow struct {
	ID          domain.MemoID
	Content     []byte
	IsArchived  bool
	IsDeleted   string
	CreatedBy   auth.AccountID
	CreatedAt   types.SQLiteDatetime
	UpdatedAt   types.SQLiteDatetime
	ID_2        int64
	MemoID      int64
	Tag         string
	CreatedAt_2 string
}

func (q *Queries) ListMemosForTagsWithSearch(ctx context.Context, db DBTX, arg ListMemosForTagsWithSearchParams) ([]ListMemosForTagsWithSearchRow, error) {
	rows, err := db.QueryContext(ctx, listMemosForTagsWithSearch,
		arg.PageAfter,
		arg.Tag,
		arg.Search,
		arg.WithCreatedAt,
		arg.CreatedAt,
		arg.WithCreatedAtOrOlder,
		arg.CreatedAtOrOlder,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemosForTagsWithSearchRow
	for rows.Next() {
		var i ListMemosForTagsWithSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.MemoID,
			&i.Tag,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemosWithSearch = `-- name: ListMemosWithSearch :many
SELECT id, content, is_archived, is_deleted, created_by, created_at, updated_at
FROM memos_fts
WHERE
    is_archived = false
    AND is_deleted = false
    AND CASE WHEN ?1 IS NOT NULL THEN created_at < datetime(?1) ELSE true END
    AND content MATCH CAST(?2 as TEXT)
    AND CASE WHEN CAST(?3 as BOOLEAN) THEN date(created_at) = date(?4) ELSE true END
    AND CASE WHEN CAST(?5 as BOOLEAN) THEN date(created_at) <= date(?6) ELSE true END
ORDER BY created_at DESC, rank
LIMIT ?7
`

type ListMemosWithSearchParams struct {
	PageAfter            interface{}
	Search               string
	WithCreatedAt        bool
	CreatedAt            interface{}
	WithCreatedAtOrOlder bool
	CreatedAtOrOlder     interface{}
	PageSize             int64
}

func (q *Queries) ListMemosWithSearch(ctx context.Context, db DBTX, arg ListMemosWithSearchParams) ([]MemoFTS, error) {
	rows, err := db.QueryContext(ctx, listMemosWithSearch,
		arg.PageAfter,
		arg.Search,
		arg.WithCreatedAt,
		arg.CreatedAt,
		arg.WithCreatedAtOrOlder,
		arg.CreatedAtOrOlder,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MemoFTS
	for rows.Next() {
		var i MemoFTS
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.IsArchived,
			&i.IsDeleted,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteMemo = `-- name: SoftDeleteMemo :exec
UPDATE memos SET
    is_deleted = true,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE id = ?
`

func (q *Queries) SoftDeleteMemo(ctx context.Context, db DBTX, id domain.MemoID) error {
	_, err := db.ExecContext(ctx, softDeleteMemo, id)
	return err
}

const updateMemoContent = `-- name: UpdateMemoContent :execrows
UPDATE memos SET
    content = ?,
    updated_at = strftime('%Y-%m-%d %H:%M:%SZ', CURRENT_TIMESTAMP)
WHERE id = ?
`

type UpdateMemoContentParams struct {
	Content []byte
	ID      domain.MemoID
}

func (q *Queries) UpdateMemoContent(ctx context.Context, db DBTX, arg UpdateMemoContentParams) (int64, error) {
	result, err := db.ExecContext(ctx, updateMemoContent, arg.Content, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
